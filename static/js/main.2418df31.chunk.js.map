{"version":3,"sources":["components/Map.tsx","hooks/useMapBBox.ts","components/MapDataLayer/BBoxApiData/BBoxApiPolylines.tsx","components/MapDataLayer/BBoxApiData/BBoxApiIsoBands.tsx","components/MapDataLayer/BBoxApiData/BBoxApiData.tsx","components/MapDataLayer/BBoxApiData/index.ts","hooks/useMapZoom.ts","components/MapDataLayer/ApiServerResponse.ts","components/MapDataLayer/VisibleFieldControl/VisibleFieldControl.tsx","components/MapDataLayer/VisibleFieldControl/index.ts","components/MapDataLayer/Legend/Legend.tsx","components/MapDataLayer/Legend/index.ts","components/MapDataLayer/WarningToast/WarningToast.tsx","components/MapDataLayer/WarningToast/index.ts","components/MapDataLayer/MapDataLayer.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Map","children","props","MapContainer","preferCanvas","TileLayer","url","attribution","React","memo","useBBox","map","useState","getBounds","bbox","setBBox","onMove","useCallback","useEffect","on","off","BBoxApiPolylines","apiStateData","visDataField","determineSegmentColor","console","log","roadData","i","segments","segment","j","Polyline","positions","shape","color","Tooltip","className","road","Object","keys","dataField","length","flat","BBoxApiIsoBands","REQUEST_HEADERS","method","mode","headers","Accept","BBoxApiData","dataBBox","valueToColorFn","zoom","request","getNorth","getWest","getSouth","getEast","apiState","useFetch","state","Rectangle","bounds","fillColor","fillOpacity","isFulfilled","data","propsChanged","prev","next","equals","useZoom","DataField","getZoom","setZoom","onZoom","dataFieldRanges","CO","CO2","NOx","PM2P5","ListMenu","VisibleFieldControl","value","setValue","allValues","field","buttonClassName","onClick","Legend","min","max","steps","perRectValue","colorRects","rectValue","push","rectWidth","rectColor","style","position","left","width","background","top","bottom","right","textAlign","fontSize","toFixed","Math","floor","WarningToast","msg","MapApiDataLayer","mapState","useMapBBox","useMapZoom","currentField","setField","fields","useDataFieldSelection","requestedData","setRequestedData","rData","lerpedValue","interpolateTurbo","valueToTurboRange","zIndex","height","bb","MAP_FILL_SCREEN_STYLE","INITIAL_LAT_LON","App","setMapState","center","whenCreated","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2418df31.chunk.js","sourcesContent":["import React from \"react\";\nimport { MapContainer, MapContainerProps, TileLayer } from \"react-leaflet\";\nimport \"leaflet/dist/leaflet.css\";\n\nconst URL =\n  \"https://{s}.basemaps.cartocdn.com/rastertiles/light_all/{z}/{x}/{y}.png\";\nconst ATTRIBUTION =\n  '&copy; <a href=\"https://openstreetmap.org\">OpenStreetMap</a>Contributors\"';\n\ntype MapProps = {} & MapContainerProps;\n\nfunction Map({ children, ...props }: MapProps) {\n  return (\n    <MapContainer\n      preferCanvas // necessary for jest testing, SVG not well supported\n      {...props}\n    >\n      {children}\n      {/* Map Tiles */}\n      <TileLayer url={URL} attribution={ATTRIBUTION} />\n    </MapContainer>\n  );\n}\n\nexport default React.memo(Map);\n","import { useState, useCallback, useEffect } from \"react\";\nimport { Map } from \"leaflet\";\n\n// gets a bounding box and dynamically updates it based on the currently visible map\nfunction useBBox(map: Map) {\n  const [bbox, setBBox] = useState(map.getBounds());\n\n  const onMove = useCallback(() => {\n    setBBox(map.getBounds());\n  }, [map]);\n\n  // adds the required event listeners for Leaflet to handle this properly\n  useEffect(() => {\n    map.on(\"moveend\", onMove);\n    map.on(\"zoomend\", onMove);\n    return () => {\n      map.off(\"moveend\", onMove);\n      map.off(\"zoomend\", onMove);\n    };\n  }, [map, onMove]);\n\n  return bbox;\n}\n\nexport default useBBox;\n","import { Polyline, Tooltip } from \"react-leaflet\";\nimport React from \"react\";\nimport ApiServerResponse, {\n  DataField,\n  SegmentInfo,\n} from \"../ApiServerResponse\";\n\nfunction BBoxApiPolylines({\n  apiStateData,\n  visDataField,\n  determineSegmentColor,\n}: {\n  apiStateData: ApiServerResponse;\n  visDataField: DataField;\n  determineSegmentColor: (value: number) => string;\n}) {\n  console.log(\"drawing polylines\", visDataField);\n  return (\n    <>\n      {apiStateData.map((roadData, i) =>\n        roadData.segments\n          .map((segment, j) => {\n            return (\n              /* Road line segments */\n              <Polyline\n                positions={segment.shape}\n                key={visDataField + \"__\" + (i * apiStateData.length + j)}\n                color={determineSegmentColor(segment[visDataField])}\n              >\n                {/* Mouseover tooltip data*/}\n                <Tooltip>\n                  <h3 className=\"road-name\">{roadData.road}</h3>\n                  {Object.keys(segment).map((dataField, i) => {\n                    if (dataField === \"shape\") return null;\n                    return (\n                      <div key={i}>\n                        <h4 className=\"field-name\">{dataField} (g / mi)</h4>\n                        {segment[dataField as keyof SegmentInfo]}\n                      </div>\n                    );\n                  })}\n                </Tooltip>\n              </Polyline>\n            );\n          })\n          .flat()\n      )}\n    </>\n  );\n}\n\nexport default BBoxApiPolylines;\n","import React from \"react\";\nimport ApiServerResponse, { DataField } from \"../ApiServerResponse\";\nimport { GeoJSON } from \"react-leaflet\";\nimport {\n  point,\n  featureCollection,\n  Feature,\n  Point,\n  Properties,\n  isobands,\n  FeatureCollection,\n} from \"@turf/turf\";\nimport { StyleFunction } from \"leaflet\";\n\nconst ISO_BAND_STYLE = {\n  opacity: 1.0,\n  fillOpacity: 0.4,\n  weight: 1.0,\n};\n\n/*\n  getGeoJSONPoints() {\n    const { lats, lons } = this.coords;\n    const pointsNested: Feature<Point, Properties>[][] = lats.map(\n      (lat: number, latIndex: number) =>\n        lons.map((lon: number, lonIndex: number) => {\n          const point = turf.point([lon, lat]);\n          const value = this.dataAtCoordinateIndex(latIndex, lonIndex);\n          // console.log(\"VALUE\", value);\n          const centroid = turf.centroid(point, { value });\n          // console.log(\"CENTROID\", centroid);\n          return centroid;\n        })\n    );\n    const points = pointsNested.flat();\n    const features = turf.featureCollection(points);\n    return features;\n  }\n\n  getAsIsobands(colorScale: ColorScale) {\n    const dataPoints = this.getGeoJSONPoints();\n    let dataShapes: FeatureCollection<\n      MultiPolygon | MultiLineString,\n      Properties\n    >;\n    try {\n      dataShapes = isobands(dataPoints, colorScale.breaks, {\n        zProperty: \"value\",\n        // TODO this is the problem with the orange I think...\n        breaksProperties: colorScale.breaks.map((cbreak) => ({ cbreak })),\n      });\n      // console.log(\"DATA SHAPES\", dataShapes);\n    } catch (errorBands) {\n      try {\n        // console.log(\"ISOBANDS BREAKS\", colorScale.breaks);\n        dataShapes = isolines(dataPoints, colorScale.breaks, {\n          zProperty: \"value\",\n        });\n        console.error(\"Failed to create data shapes: \", {\n          errorBands: errorBands,\n          dataPoints,\n          data: this,\n        });\n      } catch (errorLines) {\n        console.error(\"Failed to create data lines: \", {\n          errorLines,\n          dataPoints,\n          data: this,\n        });\n        throw new Error(\"Failed to create map data visualization layer\");\n      }\n    }\n\t*/\n\nconst createGeoJsonPoints = (\n  apiStateData: ApiServerResponse,\n  dataField: DataField\n) => {\n  const points: Feature<Point, Properties>[] = apiStateData\n    .map((roadInfo) =>\n      roadInfo.segments.map((segment) =>\n        segment.shape.map(([lat, lon]) => {\n          const value = segment[dataField];\n          return point([lon, lat], { value });\n        })\n      )\n    )\n    .flat(2);\n  console.log(points);\n  return featureCollection(points);\n};\n\nconst createIsoBands = (\n  geoJsonPoints: FeatureCollection<Point, Properties>\n) => {\n  const breaks = [0, 1, 2, 3, 4];\n  const bands = isobands(geoJsonPoints, breaks, {\n    zProperty: \"value\",\n    breaksProperties: breaks.map((cbreak) => ({ cbreak })),\n  });\n\n  // TODO why does TypeScript only like \"any\" here?\n  const styleFn: StyleFunction<any> = (\n    feature: Feature<any, any> | undefined\n  ) => {\n    if (!feature) return {};\n    // const rawValue = feature.properties!.cbreak;\n    // const value = Number(rawValue);\n    const color = \"red\";\n    return { color, fillColor: color, ...ISO_BAND_STYLE };\n  };\n\n  return {\n    bands,\n    styleFn,\n  };\n};\n\nconst createDataShapes = (\n  apiStateData: ApiServerResponse,\n  dataField: DataField\n) => {\n  const geoJsonPoints = createGeoJsonPoints(apiStateData, dataField);\n  console.log(geoJsonPoints);\n  return createIsoBands(geoJsonPoints);\n};\n\nfunction BBoxApiIsoBands({\n  apiStateData,\n  visDataField,\n  determineSegmentColor,\n}: {\n  apiStateData: ApiServerResponse;\n  visDataField: DataField;\n  determineSegmentColor: (value: number) => string;\n}) {\n  const { bands, styleFn } = createDataShapes(apiStateData, visDataField);\n  return <GeoJSON data={bands} style={styleFn} key={Date.now()} />;\n}\n\nexport default BBoxApiIsoBands;\n","import React from \"react\";\nimport { useFetch, IfPending, IfRejected, AsyncState } from \"react-async\";\nimport { LatLngBounds } from \"leaflet\";\nimport { Rectangle } from \"react-leaflet\";\nimport ApiServerResponse, { DataField } from \"../ApiServerResponse\";\nimport BBoxApiPolylines from \"./BBoxApiPolylines\";\nimport BBoxApiIsoBands from \"./BBoxApiIsoBands\";\n\nconst REQUEST_HEADERS = {\n  method: \"GET\",\n  mode: \"cors\",\n  headers: {\n    Accept: \"application/json\",\n  },\n} as RequestInit;\n\ntype BBoxApiDataProps = {\n  url: string;\n  dataField: DataField;\n  dataBBox: LatLngBounds;\n  // remove: () => void;\n  zoom: number;\n  valueToColorFn: (value: number) => string;\n};\n\nfunction BBoxApiData({\n  url,\n  dataField,\n  dataBBox,\n  // remove,\n  zoom,\n  valueToColorFn,\n}: BBoxApiDataProps) {\n  // console.log(\"loading bbox\", { dataField });\n  const request = `${url}/api/v1/bbox?ul=${dataBBox.getNorth()},${dataBBox.getWest()}&br=${dataBBox.getSouth()},${dataBBox.getEast()}`;\n  // Initialize backend communication\n  const apiState: AsyncState<ApiServerResponse> = useFetch(\n    request,\n    REQUEST_HEADERS\n  );\n\n  const renderLines = true;\n  // const renderShapes = true;\n  const renderShapes = false;\n\n  // Check if should be removed\n  // if (apiState.isRejected) remove();\n\n  return (\n    <>\n      <IfPending state={apiState}>\n        <Rectangle bounds={dataBBox} fillColor={\"grey\"} fillOpacity={0.5} />\n      </IfPending>\n      <IfRejected state={apiState}>Error Message</IfRejected>\n      {apiState.isFulfilled && apiState.data && (\n        <>\n          {renderLines && (\n            <BBoxApiPolylines\n              apiStateData={apiState.data}\n              visDataField={dataField}\n              determineSegmentColor={valueToColorFn}\n            />\n          )}\n          {renderShapes && (\n            <BBoxApiIsoBands\n              apiStateData={apiState.data}\n              visDataField={dataField}\n              determineSegmentColor={valueToColorFn}\n            />\n          )}\n        </>\n      )}\n    </>\n  );\n}\n\nconst propsChanged = (prev: BBoxApiDataProps, next: BBoxApiDataProps) =>\n  prev.dataBBox.equals(next.dataBBox) && prev.dataField === next.dataField;\n\nexport default React.memo(BBoxApiData, propsChanged);\n","import BBoxApiData from \"./BBoxApiData\";\n\nexport default BBoxApiData;\n","import { useState, useCallback, useEffect } from \"react\";\nimport { Map } from \"leaflet\";\n\nfunction useZoom(map: Map) {\n  const [zoom, setZoom] = useState(map.getZoom());\n\n  const onZoom = useCallback(() => {\n    setZoom(map.getZoom());\n  }, [map]);\n\n  useEffect(() => {\n    map.on(\"zoom\", onZoom);\n    return () => {\n      map.off(\"zoom\", onZoom);\n    };\n  }, [map, onZoom]);\n\n  return zoom;\n}\n\nexport default useZoom;\n","import { useState } from \"react\";\n\nexport enum DataField {\n  CO = \"CO\",\n  CO2 = \"CO2\",\n  NOx = \"NOx\",\n  PM2P5 = \"PM2.5\",\n}\n\nexport const useDataFieldSelection = () => {\n  const [currentField, setField] = useState(DataField.CO2);\n  const fields = [\n    DataField.CO2,\n    DataField.CO,\n    DataField.NOx,\n    DataField.PM2P5,\n  ];\n  return {\n    currentField,\n    setField,\n    fields,\n  };\n};\n\nexport const dataFieldRanges = {\n  [DataField.CO]: [0, 811],\n  [DataField.CO2]: [0, 80000],\n  [DataField.NOx]: [0, 37.5],\n  [DataField.PM2P5]: [0, 1.38],\n};\n\n// Info corresponding to a road segment, which can have 1 or more line segments\n// defined in \"shape\", but only one set of emissions data.\nexport type SegmentInfo = {\n  [DataField.CO2]: number;\n  [DataField.CO]: number;\n  [DataField.NOx]: number;\n  [DataField.PM2P5]: number;\n  shape: [number, number][];\n};\n\n// Info about a road - the \"road\" name, and the road's segments\nexport type RoadInfo = {\n  road: string;\n  segments: SegmentInfo[];\n};\n\n// Expected type of server response.\ntype ApiServerResponse = RoadInfo[];\n\nexport default ApiServerResponse;\n","import React from \"react\";\nimport \"./styles.css\";\n\nfunction ListMenu<T>({\n  value,\n  setValue,\n  allValues,\n}: {\n  value: T;\n  setValue: (value: T) => void;\n  allValues: T[];\n}) {\n  return (\n    <div className=\"field-control-menu\">\n      <ul className=\"field-control-list\">\n        {allValues.map((field, i) => {\n          const buttonClassName =\n            \"field-control-button \" +\n            (field === value ? \"field-control-button-selected\" : \"\");\n          return (\n            <li className=\"field-control-list-member\" key={i}>\n              <button\n                className={buttonClassName}\n                onClick={() => setValue(field)}\n              >\n                {field}\n              </button>\n            </li>\n          );\n        })}\n      </ul>\n    </div>\n  );\n}\n\nexport default ListMenu;\n","import VisibleFieldControl from \"./VisibleFieldControl\";\n\nexport default VisibleFieldControl;\n","import React from \"react\";\nimport \"./styles.css\";\n\nconst printValue = (value: number) => {\n  if (value === 0) return \"0\";\n  if (value < 1) return value.toFixed(2);\n  if (value < 100) return value.toFixed(1);\n  if (value < 1000) return value.toFixed(0);\n  if (value < 1000000) return Math.floor(value / 1000) + \"k\";\n};\n\nfunction Legend({\n  min,\n  max,\n  steps,\n  valueToColorFn,\n}: {\n  min: number;\n  max: number;\n  steps: number;\n  valueToColorFn: (value: number) => string;\n}) {\n  // const rectWidth = Math.ceil(width / steps);\n  // TODO is this right? Works for min = 0 for sure, that might be all we need\n  const perRectValue = (max - min) / steps;\n  const colorRects = [];\n  for (let i = 0; i <= steps; ++i) {\n    const rectValue = perRectValue * i;\n    colorRects.push(valueToColorFn(rectValue));\n  }\n  const rectWidth = 100 / (steps + 1);\n  return (\n    <div className=\"legend-bg\">\n      {colorRects.map((rectColor, i) => (\n        <div\n          key={i}\n          style={{\n            position: \"absolute\",\n            left: `${rectWidth * i}%`,\n            width: `${rectWidth}%`,\n            background: rectColor,\n            top: 0,\n            bottom: \"50%\",\n          }}\n        >\n          <div\n            style={{\n              position: \"absolute\",\n              top: \"100%\",\n              left: \"5px\",\n              right: \"5px\",\n              textAlign: \"center\",\n              background: \"white\",\n              color: \"black\",\n              fontSize: \"12px\",\n            }}\n          >\n            {printValue(perRectValue * i)}\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n}\n\nexport default Legend;\n","import Legend from \"./Legend\";\n\nexport default Legend;\n","import React from \"react\";\nimport \"./styles.css\";\n\nfunction WarningToast({ msg }: { msg: string }) {\n  return <div className=\"warning-toast \">{msg}</div>;\n}\n\nexport default WarningToast;\n","import WarningToast from \"./WarningToast\";\n\nexport default WarningToast;\n","import React, { useEffect, useState } from \"react\";\nimport { Map as LeafletMapData, LatLngBounds } from \"leaflet\";\nimport useMapBBox from \"../../hooks/useMapBBox\";\nimport BBoxApiData from \"./BBoxApiData\";\nimport useMapZoom from \"../../hooks/useMapZoom\";\nimport { dataFieldRanges, useDataFieldSelection } from \"./ApiServerResponse\";\nimport VisibleFieldControl from \"./VisibleFieldControl\";\nimport Legend from \"./Legend\";\nimport { interpolateTurbo } from \"d3\";\nimport WarningToast from \"./WarningToast\";\n\nconst ZOOM_MIN = 13;\n\nconst valueToTurboRange = (value: number, min: number, max: number): string => {\n  const lerpedValue = (value - min) / (max - min);\n  return interpolateTurbo(lerpedValue);\n};\n\n/*\n  Tracks the map's bounding box, and triggers requests to the backend when it changes.\n  It does this through the BBoxData component, just by adding one. That component\n  talks to the backend directly.\n*/\nfunction MapApiDataLayer({\n  url,\n  mapState,\n}: {\n  url: string;\n  mapState: LeafletMapData;\n}) {\n  // lat/lon locations representing the corners of the visible map, dynamically updating\n  const bbox = useMapBBox(mapState);\n  const zoom = useMapZoom(mapState);\n  const { currentField, setField, fields } = useDataFieldSelection();\n\n  const [requestedData, setRequestedData] = useState([bbox] as LatLngBounds[]);\n\n  const [min, max] = dataFieldRanges[currentField];\n\n  useEffect(() => {\n    if (zoom < ZOOM_MIN) return;\n    /*\n    // expect to update by default\n    let shouldUpdate = true;\n    // check if bbox is *entirely* contained within another single bbox\n    // TODO\n    // a lot more could be done to make it smarter about knowing when it has all\n    // required data on screen, or requesting only sections of a screen\n    // but this alone helps a lot\n    requestedData.forEach((bb) => {\n      if (!bbox) throw new Error(\"bbox is null in requestedData update\");\n      if (bb.contains(bbox)) shouldUpdate = false;\n    });\n\n    // all expected data is already displayed on the map, no need to request more\n    if (!shouldUpdate) return;\n\n    setRequestedData((rData) => [...rData, bbox] as LatLngBounds[]);\n    */\n    setRequestedData((rData) => [bbox] as LatLngBounds[]);\n  }, [bbox, zoom]);\n\n  /*\n  const removeBBoxData = (bb: LatLngBounds) => {\n    var bboxIndex = requestedData.indexOf(bb);\n    setRequestedData((rData) => [...rData].splice(bboxIndex, 1));\n  };\n  */\n\n  const valueToColorFn = (value: number) => valueToTurboRange(value, min, max);\n\n  return (\n    <>\n      <div\n        style={{\n          position: \"absolute\",\n          width: \"500px\",\n          left: \"60px\",\n          top: \"10px\",\n        }}\n      >\n        <VisibleFieldControl\n          value={currentField}\n          setValue={setField}\n          allValues={fields}\n        />\n      </div>\n      <div\n        style={{\n          position: \"absolute\",\n          width: \"408px\",\n          left: \"60px\",\n          top: \"40px\",\n          zIndex: 1000,\n          height: \"34px\",\n        }}\n      >\n        <Legend\n          min={min}\n          max={max}\n          steps={10}\n          valueToColorFn={valueToColorFn}\n        />\n      </div>\n      {zoom < ZOOM_MIN && (\n        <WarningToast msg={\"Warning: Zoomed out too far to load new data.\"} />\n      )}\n      {requestedData.map((bb, i) =>\n        bb ? (\n          <BBoxApiData\n            url={url}\n            zoom={zoom}\n            dataBBox={bb}\n            dataField={currentField}\n            key={i}\n            // TODO this is a good idea but when the backend can't be reached it crashes hard\n            // remove={() => removeBBoxData(bb)}\n            valueToColorFn={valueToColorFn}\n          />\n        ) : null\n      )}\n    </>\n  );\n}\n\nexport default React.memo(MapApiDataLayer);\n","import React, { useState } from \"react\";\nimport Map from \"./components/Map\";\nimport \"./App.css\";\nimport { Map as LeafletMapData } from \"leaflet\";\nimport { LatLngExpression } from \"leaflet\";\nimport MapApiDataLayer from \"./components/MapDataLayer/MapDataLayer\";\n\n// In production, talk to production. In development, prefer REACT_APP_API_URL variable\n// (e.g. from command `REACT_APP_API_URL=localhost:8000 npm start`)\n// Otherwise fall back to production server\nconst API_URL =\n  process.env.NODE_ENV === \"production\" || !process.env.REACT_APP_API_URL\n    ? \"https://car-dependence-backend.herokuapp.com/api/route/\"\n    : process.env.REACT_APP_API_URL;\nif (process.env.NODE_ENV !== \"production\")\n  console.info(`Using API endpoint ${API_URL}`);\n\n// Fill screen\nconst MAP_FILL_SCREEN_STYLE = { width: \"100vw\", height: \"100vh\" };\n\n// Default values (Portland)\nconst INITIAL_LAT_LON = [45.5051, -122.675] as LatLngExpression;\nconst INITIAL_ZOOM = 13;\n\nfunction App() {\n  // gets initiated by React-Leaflet in whenCreated\n  const [mapState, setMapState] = useState(null as LeafletMapData | null);\n\n  return (\n    <div className=\"App\">\n      <Map\n        style={MAP_FILL_SCREEN_STYLE}\n        center={INITIAL_LAT_LON}\n        zoom={INITIAL_ZOOM}\n        // sets up the useState hook so we can monitor Leaflet state externally\n        whenCreated={setMapState}\n      >\n        {mapState && <MapApiDataLayer mapState={mapState} url={API_URL} />}\n      </Map>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}